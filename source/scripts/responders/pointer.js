// Skin.js 0.1.4
// Â© 2013 Soheil Jadidian
// Skin.js may be freely distributed under the MIT license
// http://skinjs.org

define('responders/pointer', ['skin'], function(Skin) {

  // Pointer Responder Module
  // ========================
  // hooks for mouse, pen or touch events
  // supports pointerdown, pointerup, pointermove, pointercancel, pointerover, pointerout

  var w = window, d = document, n = w.navigator, Tools = Skin.Tools, hub = {}, indices = []
    , down   = /(start|down)$/i
    , move   = /move$/i
    , up     = /(up|end)$/i
    , cancel = /cancel$/i
    , over   = /(over|enter)$/
    , out    = /(out|leave)$/;

  // supported events
  // ----------------
  // press:         tap, click, pointerdown followed by pointerup
  // doublepress:   double tap or double click, press press
  // longpress:     hold, long tap, long click, pointerdown and pointerup with delay
  // controlpress:  right click, contextmenu, pointerdown followed by pointerup with key type, altKey shiftKey or ctrlKey
  // wheel:         mousewheel, might be generated by device on two finger panning
  // pointerdown:   mousedown, touchstart
  // pointerup:     mouseup, touchend
  // pointermove:   mousemove, touchmove
  // pointercancel: touchcancel
  // pointerover:   mouseenter, mouseover without bubbling
  // pointerout:    mouseleave, mouseout without bubbling
  // dragstart:     pointerdown followed by pointermove
  // dragover:      dragstart, followed by pointerover or touchenter if supported
  // dragout:       dragstart, followed by pointerout or touchleave if supported
  // dragend:       dragstart, followed by pointerup, or pointercancel
  // drag:          dragstart, pointermove
  // drop:          dragstart, followed by pointerup on specific target
  // swipestart, swipe, swipeend
  // panstart, pan, panend
  // rotatestart, rotate, rotateend
  // pinchstart, pinch, pinchend

  // check if browser supports an event
  function isSupported(name) {
    var element = d.createElement('div'), cache = {}, flag;
    name = 'on' + name;
    if (cache[name]) return cache[name];
    flag = (name in element);
    if (!flag) {
      element.setAttribute(name, 'return;');
      flag = typeof element[name] === 'function';
    }
    element = null;
    cache[name] = flag;
    return flag;
  }

  // get a nested element's offset, according to document
  function offset(element) {
    var x = 0, y = 0, pointer = element;
    while (pointer !== null) {
      x += pointer.offsetLeft;
      y += pointer.offsetTop;
      pointer = pointer.offsetParent;
    }
    return { x: x, y: y };
  }

  // prevent default browser actions
  function prevent(event) {
    if (event.preventDefault) event.preventDefault();
    if (event.preventManipulation) event.preventManipulation();
    if (event.preventMouseEvent) event.preventMouseEvent();
  }

  // ensure coordinate is inside the element
  function sanitizeCoordinate(element, coordinate) {
    var offset = offset(element);
    return {
      x: Math.max(0, Math.min(coordinate.x - offset.x, element.offsetWidth))
    , y: Math.max(0, Math.min(coordinate.y - offset.y, element.offsetHeight))
    };
  }

  // find supported event type based on name
  function typeOfName(name) {
    switch (name) {
      case 'pointerdown':
        return isSupported('pointerdown') ? 'pointerdown'
             : isSupported('touchstart') ? 'touchstart'
             : n.msPointerEnabled ? 'MSPointerDown'
             : 'mousedown';

      case 'pointerup':
        return isSupported('pointerup') ? 'pointerup'
             : isSupported('touchend') ? 'touchend'
             : n.msPointerEnabled ? 'MSPointerUp'
             : 'mouseup';

      case 'pointermove':
        return isSupported('pointermove') ? 'pointermove'
             : isSupported('touchmove') ? 'touchmove'
             : n.msPointerEnabled ? 'MSPointerMove'
             : 'mousemove';

      case 'pointercancel':
        return isSupported('pointercancel') ? 'pointercancel'
             : isSupported('touchcancel') ? 'touchcancel'
             : n.msPointerEnabled ? 'MSPointerCancel'
             : null;

      case 'pointerover':
        return isSupported('mouseenter') ? 'mouseenter'
             : 'mouseover';

      case 'pointerout':
        return isSupported('mouseleave') ? 'mouseleave'
             : 'mouseout';

      default:
        return null;
    }
  }

  // find standard event name based on type
  function nameOfType(type) {
    return move.test(type) ? 'pointermove'
         : over.test(type) ? 'pointerover'
         : out.test(type) ? 'pointerout'
         : down.test(type) ? 'pointerdown'
         : up.test(type) ? 'pointerup'
         : 'pointercancel';
  }

  // element or emitter, event's name, context or callback
  // callback is intended to be used by more complex responders
  // if callback is specified, it means other responders will
  // handle the event, so it won't be registered in hub and handled here
  function add(element, name, context, callback) {
    var type = typeOfName(name);
    if (type) {
      if (callback) {
        // handled by other responders
        element.addEventListener(type, callback, false);
      } else {
        var path = Tools.indexFor(indices, element) + '.' + name;
        if (hub[path]) {
          hub[path].push(context);
        } else {
          hub[path] = [context];
          element.addEventListener(type, handle, false);
        }
      }
    }
  }

  function remove(element, name, context, callback) {
    // special case, when there's no name it means
    // all handlers for the specified context should be removed
    // this is when something like context.off(element) was used
    if (!name.length) {
      Tools.each(hub, function(contexts, path) {
        Tools.reject(contexts, function(which) { return which === context; });
        if (!contexts.length) {
          var type = typeOfName(path.split('.')[1]);
          element.removeEventListener(type, handle);
          delete hub[path];
        }
      });
      return;
    }

    // normal case, name is specified
    var type = typeOfName(name);
    if (type) {
      if (callback) {
        // handled by other responders
        element.removeEventListener(type, callback);
      } else {
        var path = Tools.indexFor(indices, element) + '.' + name;
        if (hub[path]) {
          Tools.remove(hub[path], context);
          if (!hub[path].length) {
            element.removeEventListener(type, handle);
            delete hub[path];
          }
        }
      }
    }
  }

  function handle(event) {
    var element = event.currentTarget
      , name    = nameOfType(event.type)
      , path    = Tools.indexFor(indices, element) + '.' + name;

    if (hub[path]) {
      event.stopPropagation();
      Tools.each(hub[path], function(context) {
        context.trigger(element, name, { x: event.clientX, y: event.clientY, event: event });
      });
    }
  }


  var Pointer = Skin.Responders.Pointer = { add: add, remove: remove };
  return Pointer;
});